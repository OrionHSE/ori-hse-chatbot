<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>ORI-HSE Assistant</title>

  <style>
    :root { --vh: 1vh; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f7f7f8;
    }

    .page {
      height: calc(var(--vh, 1vh) * 100);
      display: flex;
      flex-direction: column;
      background: #f7f7f8;
    }

    body.embedded .page { height: 100%; }

    .chat-header {
      background: linear-gradient(135deg, #004c9d 0%, #00a59b 100%);
      color: #fff;
      padding: 14px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 18px;
      font-weight: 600;
    }

    .chat {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin: 0 auto;
      width: 100%;
      min-height: 0;
    }

    .chat-messages {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding: 20px;
      background: #f7f7f8;
    }

    .message { margin-bottom: 16px; display: flex; animation: slideIn .3s ease-out; }
    @keyframes slideIn { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }

    .message-content {
      max-width: 75%;
      padding: 10px 14px;
      border-radius: 16px;
      word-wrap: break-word;
      font-size: 14px;
      line-height: 1.4;
      background: #fff;
      color: #333;
      border-bottom-left-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,.08);
    }

    .message.user { justify-content: flex-end; }
    .message.user .message-content {
      background: linear-gradient(135deg, #004c9d 0%, #00a59b 100%);
      color: #fff;
      border-bottom-right-radius: 4px;
      box-shadow: none;
    }

    .chat-input-container {
      border-top: 1px solid #e6e6e6;
      background: #f7f7f8;
      padding: 12px 20px 20px;
    }

    .chat-input-wrapper {
      display: flex;
      gap: 8px;
      max-width: 860px;
      margin: 0 auto;
    }

    .chat-input {
      flex: 1;
      padding: 10px 14px;
      border: 2px solid #e0e0e0;
      border-radius: 20px;
      font-size: 14px;
      outline: none;
      transition: border-color .3s;
      resize: none;
      line-height: 1.4;
    }

    .chat-input:focus { border-color: #004c9d; }

    .send-button {
      padding: 10px 20px;
      border: none;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, #004c9d 0%, #00a59b 100%);
      cursor: pointer;
    }

    .send-button:disabled { opacity: .6; cursor: not-allowed; }

    .loading {
      display:flex; gap:4px; padding:10px 14px;
      background:#fff; border-radius:16px;
    }

    .loading-dot {
      width:8px; height:8px; border-radius:50%;
      background:#004c9d; animation:bounce 1.4s infinite ease-in-out;
    }
    .loading-dot:nth-child(1){ animation-delay:-.32s; }
    .loading-dot:nth-child(2){ animation-delay:-.16s; }
    @keyframes bounce { 0%,80%,100%{transform:scale(0);} 40%{transform:scale(1);} }

    .message.assistant .message-content ul { margin: 8px 0 8px 18px; }
    .message.assistant .message-content li { margin: 4px 0; }
    .message.assistant .message-content p { margin: 6px 0; }

    @media (max-width: 480px) {
      .message-content { max-width: 88%; }
      .chat-header { font-size: 16px; padding: 12px 16px; }
    }
  </style>

  <script>
    // Mobile viewport fix
    function setVh() {
      document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
    }
    window.addEventListener('load', setVh);
    window.addEventListener('resize', setVh);

    // Detect if embedded (Google Sites)
    function detectEmbedded() {
      if (window.self !== window.top) {
        document.body.classList.add('embedded');
      }
    }
    window.addEventListener('load', detectEmbedded);
  </script>
</head>

<body>
  <div class="page">
    <div class="chat-header">
      <div>ORI-HSE Assistant</div>
    </div>

    <div class="chat">
      <div class="chat-messages" id="chatMessages">
        <div class="message assistant">
          <div class="message-content">
            ðŸ‘‹ Hello! I'm ORI â€” your Orion HSE Assistant.<br>
            I can help answer questions based on our policies.<br>
            ðŸ’¬ <em>(TambiÃ©n sÃ© espaÃ±ol â€” Â¡PregÃºntame algo!)</em>
          </div>
        </div>
      </div>

      <div class="chat-input-container">
        <div class="chat-input-wrapper">
          <textarea
            class="chat-input"
            id="chatInput"
            placeholder="Ask ORI... / PregÃºntame algo..."
            rows="1"
          ></textarea>
          <button class="send-button" id="sendButton">Send</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <script>
    const chatMessages = document.getElementById('chatMessages');
    const inputEl = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendButton');

    // Auto grow textarea
    function autogrow() {
      inputEl.style.height = 'auto';
      inputEl.style.height = Math.min(inputEl.scrollHeight, 160) + 'px';
    }
    inputEl.addEventListener('input', autogrow);
    autogrow();

    function scrollToBottom() { chatMessages.scrollTop = chatMessages.scrollHeight; }

    function addMessage(content, role) {
      const wrap = document.createElement('div');
      wrap.className = `message ${role}`;
      const bubble = document.createElement('div');
      bubble.className = 'message-content';
      bubble.innerHTML = role === 'user' ? escapeHtml(content) : content;
      wrap.appendChild(bubble);
      chatMessages.appendChild(wrap);
      scrollToBottom();
      return bubble;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Typing animation fallback
    function typeOutMarkdown(targetEl, fullText, speed = 12, step = 3) {
      let i = 0;
      const timer = setInterval(() => {
        i += step;
        targetEl.innerHTML = marked.parse(fullText.slice(0, i));
        scrollToBottom();
        if (i >= fullText.length) clearInterval(timer);
      }, speed);
    }

    // Enter/Shift+Enter handler
    inputEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    sendBtn.addEventListener('click', sendMessage);

    async function sendMessage() {
      const text = (inputEl.value || '').trim();
      if (!text) return;

      addMessage(text, 'user');
      inputEl.value = '';
      autogrow();

      const loadingHTML = `
        <div class="loading">
          <div class="loading-dot"></div>
          <div class="loading-dot"></div>
          <div class="loading-dot"></div>
        </div>`;
      const assistantBubble = addMessage(loadingHTML, 'assistant');

      try {
        const resp = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text })
        });

        if (!resp.ok || !resp.body) {
          assistantBubble.textContent = 'Error: could not stream reply.';
          return;
        }

        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        assistantBubble.innerHTML = '';

        let fullText = '';
        let updates = 0;

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          if (chunk === '[END]') break;

          fullText += chunk;
          updates++;

          if (updates > 2) {
            assistantBubble.innerHTML = marked.parse(fullText);
            scrollToBottom();
          }
        }

        if (updates <= 2) {
          typeOutMarkdown(assistantBubble, fullText.trim(), 10, 2);
        } else {
          assistantBubble.innerHTML = marked.parse(fullText.trim());
          scrollToBottom();
        }

      } catch (err) {
        console.error(err);
        assistantBubble.textContent = 'Network error.';
      }
    }
  </script>
</body>
</html>
